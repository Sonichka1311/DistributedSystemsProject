# Online Store
This is a university project for Distributed Systems course.

There are some microservices such as rest-api main service for store, authorization service, big files loader and database.

![schema](https://github.com/Sonichka1311/DistributedSystemsProject/blob/master/schema.png?raw=true)

## REST API
Handlers:
* `GET /` - get all products in shop.
* `GET /?page=*&count=*` - get all products with pagination (products from number `(page - 1) * count` to number `page * count`). CGI params: `page` - current page, `count` - number of products in one page.
* `GET /product?id=*` - get product by `id`. CGI param `id` - identifier, automatically generated by database when creating the product.
* `POST /product` - add new product. Body: JSON of type { `"name"` : string , `"category"` : string }. Need authorization header.
* `PUT /product` - edit the product. Body: JSON with fields: `"id"`: integer (required), `"name"`: string (optional) and `"category"`: string (optional). Updates product with `id=*` by fields `name` and `category` if specified. Need authorization header.
* `DELETE /product` - delete product by `id`. Body: JSON of type {`"id"`: integer}. Need authorization header.

## Products
Product is JSON with fields:
- `name` (product name of type string, e.g. "banana", "MacBook Pro 2019", "blue blouse")
- `id` (product identifier of type integer, generated automatically)
- `category` (type of product, e.g. "fruit", "computer", "clothes")

## Roles
Now there are three roles:
- unauthorized user (user, who has no access token). Can see products.
- authorized user (user with simple access token). Now it is just like unauthorized user, but I plan to modify its functionality.
- admin (user with admin access token). Can add, edit and delete products.

## Authorization
You need access token if you want more that look at products. Get access token in authorization service and put it to header "AccessToken".

Authorization service has next handlers:
* `POST /signup` - sign up. Body: JSON with fields: `"email"`: string (required), `"password"`: string (required) and `"phone"`: string (optional, just numbers, without `+`, `-` and spaces). If success, sends message with confirmation link to e-mail (now just to console) and to phone (if specified).
* `POST /signin` - sign in. Body: JSON of type { `"email"`: string , `"password"`: string }. Returns JSON with fields: `"access_token"` (for access, available for short time) and `"refresh_token"` (for updating expired access token, available for long time), if user is signed up, error otherwise.
* `POST /refresh` - refresh expired access token. Body: JSON of type: { `"refresh_token"`: string }. Returns JSON with new access Ð¸ refresh tokens in sign in format, if old refresh_token was not expired.
* `POST /upgrade` - add admin. Body: JSON of type { `"email"`: string }, where email is email user, which you want to upgrade. Need authorization header with admin access token.
* `POST /downgrade` - downgrage admin to user. Body: JSON of type { `"email"`: string }, where email is email user, which you want to downgrade. Need authorization header with admin access token.

There is a superadmin, who can add admins, but can't be downgraded by other admins.

Also authorization service validates tokens for other services using gRPC.

## Notifications
When you sign up in service, you get a letter (or sms) with confirmation link. You need to open it to confirm your register. The main service sends these requests to messages queue (RabbitMQ), and then notification service get message from queue and send it. Now e-mails are sended just to console, but sms are really sended to phone.

## Upload products
If you are an admin, you can add new products. It can be done by `POST /product` or `POST /upload?type=*`. If you want to add more than one product in once, you should use uploader. CGI param `type` is a type of the file you uploading, it can be csv or xml. You should use form-data body with field `file`: yourfilename.csv (or .xml). And you also need an admin authorization header.

Your file are split into small blocks and put in message queue. Then uploader service takes blocks from queue and handle it.

If you want to get status your uploading, you should use `GET /info` with your access token in header.

## Install&&Launch
```
git clone https://github.com/Sonichka1311/DistributedSystemsProject.git
cd DistributedSystemsProject
docker-compose up
```
